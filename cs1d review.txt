Review
1. Queues
2. Heaps
3. Hashing
4. Sorting
5. Graphs (BFS/DFS/etc.)
6. MST
7. LCS - x
8. Floyd-Warshall
9. Boyer Moore - x
10. KMP - x
11.Huffman coding - x
12. Quick selection
13. AVL trees
14. Splay trees
15. 2-4 trees
16. Red-black trees
17. Prefix tries - x
18. Suffix tries - x 

Brute Force String Matching
procedure BruteForce(T[0..n) (text), P[0..m) (pattern))
  for i = 0, .., n-m-1 do
    for j = 0,..,m-1 do
       if T[i+j] != P[j] then break inner loop
     if j == m then return i (match at i)
  return NO_MATCH performance (m x n)

Knuth Morris Pratt String Matching
KMP(T[0..n - 1), P[0..m-1))
  fail[0..m] = failureLinks(P)
  i = 0
  j = 0
  while i < n do
    if T[i] == P[j] then
      i++; j++
      if j == m then
        return i - j // found
    else // mismatch
      if j >= 1
        j = fail[j] // follow one x
      else 
	i++
  end while
  return NO_MATCH (performance 2N) = total performance O(n + m)

procedure failureLinks(P[0..m -1]) - performance O(m)
  fail[0] = 0
  x = 0
  for j = 1,...,m -1 do
    fail[j] = x
    // while P[x] != P[j]
         if x == 0 then
           x = -1; break
         else
	   x = fail[x]
       end while
       x++
  end for (performance 2m)


KMP prefix function (failure) (1D version)
  - length of the longest prefix P[0..j) that is a suffix of P[1..j)
  F[0] = 0
  i = 1
  j = 0
  while i < m
    if P[i] == P[j]
      // matched j + 1 chars
      F[i] = j + 1
      i++
      j++
    else if j > 0 then
      // use failure function to shift P
      j = F[j - 1]
    else
      F[i] = 0 // no match
      i++


*** LCS
Algorithm LCS(X, Y): running time O(nm) (Dynamic Programming)
  Input: String X and Y with n and m elements
  Output: For i = 0,...,n-1  j = 0,...,m-1, the length L[i,j] of a longest string
          that is a subsequence of both the string X[0..i] = x0x1x2..xi and
          string Y[0..j] = y0y1y2...yj
  for i = 1 to n-1 do
    L[i,-1] = 0
  for j = 0 to m-1 do
    L[-1,j] = 0
  for i = 0 to n-1 do
    for j = 0 to m-1 do
       if x[i] = y[j] then
	 L[i,j] = L[i-1,j-1] + 1 // count the match
       else
	  L[i,j] = max{L[i-1,j], L[i,j-1]} // no match
  return array L


*** Brute Force String Matching
Algorithm BruteForceMatch(T,P)
  Input: text T of size n and pattern P of size m
  Output: starting index of a substring of T equal to P or -1 no match
  for i = 0 to n-m
    j = 0
    while j < m and T[i+j] == P[j]
      j++
      if j = m return i // matched at i
  return -1 // no match


*** Boyer Moore String Matching
last(c) - performance O(m + size of alphabet)

Algorithm BoyerMooreMatch(T, P) - performance O(nm + s) s is alphabet size
  compute function last
  i = m - 1
  j = m - 1
  repeat
    if T[i] = P[j]
      if j = 0
        return i // match at i
      else
        i--
        j--
    else
      // character jump - mismatch
      i = i + m - min(j, 1 + last(T[i])
      j = m - 1
  until i > n - 1
  return -1 // no match

Algorithm HuffmanEncoding(X) - performance O(n +d log d) n is size of X, 
		d is number of distince characters
  Input: string X of size n
  Output: optimal encoding trie for X
  C = distinctCharacters(X)
  computeFrequencies(C,X)
  Q = new empty heap
  for all c e C
    T = new single node tree storing c
    Q.insert(getFrequency(c), T)
  while O.size() > 1
    f1 = Q.minKey()
    T1 = Q.removeMin()
    f2 = Q.minKey()
    T2 = Q.removeMin()
     T = join(T1, T2)
    Q.insert(f1 + f2, T)
  return Q.removeMin()

Tries - looking up data in a trie is faster in the worst case O(m) where
  m is the length of the search string, uses more memory than hash tables










 